package jianzhioffer;

/**
 这道题是考察位运算， & | ^ 和 << >>操作
 看到题目第一反应是除以2，但同时担心一个问题：那就负数的情况，用补码就比较复杂，且可能还要考虑int在32位机和64位机的区别。
 记住：除法的效率是远低于移位运算的，实际编程中尽量使用移位运算符代替除法。

 先介绍下<< 和 >> 操作,
 左移操作符<<: m << n，表示把m左移n位，最左边的n位将会被丢弃；
 右移操作符>>：右移n位，最右边的n位将被丢弃，
 如果数字是无符号数值时，用0填充最左边的n位；
 如果数字是有符号数值时，
 若数值是正数，用0填充；
 否则，用1填充。

 因此，形成一个基本思路：
 先判断整数（假设是正数）二进制中最右边一位是不是1；
 然后把输入的整数整体向右移动一位，直到整个整数变成0为止。
 那么如何判断整数最右边是不是1，只要把整数和1做与操作(&)，看结果是不是0。
 */
public class offer15 {
    public int NumberOf1(int n) {
        /*
        //AC不过，因为有死循环
        //未考虑负数的情况，若出现负数，则将会死循环
        int count = 0;
        while(n != 0) {
            if((n&1) != 0) count++;
            n = n >> 1;
        }
        return count;
        */

        //避免死循环
        //基本思路，既然右移碰见负数会造成死循环，那么想到不右移n，左移1，将1定义成无符号整数，但是java没有无符号整数，怎么办？
        //直接用正数1代替，因为正数的二进制开头一定是0
        int count = 0;
        int flag = 1;
        while(flag != 0) {
            if((n&flag) != 0) count++;
            flag = flag << 1;
        }
        return count;
    }
}